{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cast","text":"<p>Cast is an installer tool for any Cast distro like SIFT or REMNUX.</p> <p></p>"},{"location":"#usage","title":"Usage","text":"<pre><code>cast install &lt;owner/repo|alias&gt;\n</code></pre> <p>Note: there are only two aliases currently supported, <code>sift</code> and <code>remnux</code> which are resolved to <code>teamdfir/sift-saltstack</code> and <code>remnux/salt-states</code> respectively.</p>"},{"location":"#what-is-a-cast-distro","title":"What is a Cast Distro?","text":"<p>Simply put a cast distro is one published by the cast binary, however it's a bit more complicated than that.</p> <p>The underlying technology used for installing the distro is Saltstack.</p> <p>There are only two (2) version 1 cast distros out there and they are SIFT and REMnux and what makes them a v1 is the way the release files are generated and signed and how the saltstack files are organized in the repository.</p> <p>A version 2 cast distro is one like example-distro-saltstack where the salt states start in the root of the project and the release is generated by the <code>cast-devtools</code>. The reason for moving the states to the root is for <code>git submodule</code> usage for distros that extend another distro.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Cast is configured via the <code>.cast.yml</code> file in the root of the cast distro project. This configuration is required and contains important information like what GitHub Repository should releases be published to, what the manifest file contents should be.</p> <p>Part of the configuration is the <code>manifest</code> definition that ultimately gets uploaded as a release asset. The manifest dictates things like <code>base</code>, <code>modes</code>, and <code>supported operating systems</code>.</p> <ul> <li><code>base</code> - this is the name of the base directory that the files should be extracted into</li> <li><code>modes</code> - this is a way to define modes that the user can specify along with the default mode, if none is specified</li> <li><code>supported_os</code> - this is a way to define what operating systems are supported</li> </ul>"},{"location":"#for-developers","title":"For Developers","text":"<p>If your distro is called <code>alpha</code> then your <code>base</code> should be <code>alpha</code>, all salt states will be homed into a directory called <code>alpha</code></p>"},{"location":"#aliases","title":"Aliases","text":"<p>Cast has the concept of aliases and it's possible to add additional distros to this alias list.</p> <p>However the aliases serve a more specific purpose for supporing backwards compatibility for older versions of SIFT and REMnux that were not released as a cast distro originally.</p>"},{"location":"#developers","title":"Developers","text":"<p>Developing a distro for cast is very simple, this documentation will walk you through cast initialization.</p>"},{"location":"#saltstack","title":"Saltstack","text":"<p>To make embedding a distro easier in another distro both for the community and for SANS builds purposes, the salt states have now been moved to the root of the project. This allows for a repo to be submoduled into another repo and the <code>manifest.yml</code> dictates to the installer how things should be extracted and installed.</p> <p>Futhermore the <code>devtools</code> contains commands to help developers test their states in the correct structure format.</p>"},{"location":"#release","title":"Release","text":"<p>Requirements</p> <ul> <li>Tag must be created outside of the tool and pushed to the remote</li> <li>Cosign private key and public key must be present in the repo</li> </ul> <p>Creating a release has never been more simply. However one thing is required, that you tag and push the tag to GitHub prior to running the command.</p> <pre><code>git tag v1.0.0 &amp;&amp; git push origin --tags\n</code></pre> <p>Then you simply run the release command from your local branch.</p> <pre><code>cast-devtools release\n</code></pre>"},{"location":"distro/","title":"Distro","text":"<p>A Cast Distro is simply a self contained set of Saltstack states that get bundled up by the Cast binary such that they are signed and downloadable by the tool to be installed against a linux system.</p> <p>If you are familiar with Saltstack this should be a fairly straightfoward process, if you are however unfamiliar with Saltstack some additional learning will be required to get up to speed, to help with that there's a saltstack primer located in this documentation.</p>"},{"location":"distro/#organization","title":"Organization","text":"<p>The most important aspect of a Cast distro is how the salt states are organized. Typically speaking you'd have a directly, let's call it <code>example</code> and within it you'd define a state file <code>server.sls</code> and this file would do something like <code>pkg.install</code> of <code>htop</code>. However to allow Cast distributions to be required by other Cast distributions, we leave the creation of the folder <code>example</code> up to Cast, instead a manifest is defined to set the name of the project (aka base) of where all the files starting at the root of the repository will be extracted to. The primary purpose for this is to allow another distro to use <code>git submodules</code> to essentially include distro A into distro B.</p>"},{"location":"distro/#manifest","title":"Manifest","text":"<p>The manifest is a file that is included with the releases assets on a GitHub Release that provides context to the installer for the distro.</p>"},{"location":"distro/#specification","title":"Specification","text":"<p>Note: <code>base_dir</code> is if the base of the salt states are in a directory other than the root of the project.</p> <pre><code>name: sift\nbase_dir: sift\nmodes:\n  - name: desktop\n    state: sift.desktop\n  - name: server\n    state: sift.server\n    default: true\n  - name: packages-only\n    state: sift.server\n    deprecated: true\n    replacement: server\n  - name: complete\n    state: sift.desktop\n    deprecated: true\n    replacement: desktop\nsupported_os:\n  - id: ubuntu\n    release: 20.04\n    focal: focal\nsaltstack:\n  pillars:\n    distro_user_template: '{{ .User }}'\n</code></pre>"},{"location":"distro/#modes","title":"Modes","text":"<p>Modes are essentially aliases and born from the original install tools from SIFT and REMnux. These <code>modes</code> allow for defining a single name alias like <code>desktop</code> to point to <code>sift.desktop</code></p>"},{"location":"distro/#supported-operating-systems-os","title":"Supported Operating Systems (OS)","text":"<p><code>SupportedOS</code> allows for defining what operating systems are officially supported by the distro.</p> <pre><code>supported_os:\n  - id: ubuntu\n    release: 20.04\n    focal: focal\n</code></pre>"},{"location":"distro/#saltstack","title":"SaltStack","text":"<p>The <code>saltstack</code> sections allows for configuring aspects of SaltStack. At this time it only allows for passing custom pillar data.</p>"},{"location":"distro/#pillars","title":"Pillars","text":"<p>Pillars are essentially data that's made available to the SaltStack run, currently it only supports a <code>key: value</code> format, it does not support nested data.</p> <p>Important</p> <p>The <code>_template</code> suffix has special meaning. It indicates a template variable, the value before the <code>_template</code> is the actual end result variable name. (eg <code>sift_user_template</code> becomes <code>sift_user</code>)</p> <pre><code>saltstack:\n  pillars:\n    sift_user_template: \"{{ .User }}\"\n</code></pre>"},{"location":"distro/#template-data","title":"Template Data","text":"<p>This is the data available to the template process.</p> <pre><code>user: SUDO_SUER\n</code></pre> <ul> <li>user, this is the CLI option <code>--user</code> but defaults to <code>SUDO_USER</code> environment variable, as the tool is only suppose to be run with sudo.</li> </ul>"},{"location":"migrate/","title":"Migrating to Cast","text":"<p>This is a migration guide for existing distros that are using some variation of the <code>sift-cli</code> like SIFT or REMnux.</p>"},{"location":"migrate/#overview","title":"Overview","text":"<p>Cast is a singlular tool designed to install, test and release cast compatible distributions that are built with SaltStack.</p> <p>It uses a single file in the project root called <code>.cast.yml</code> to define how releases and installations take place.</p> <p>Cast uses cosign to sign all releases but supports the legacy PGP signing that the <code>sift-cli</code> and <code>remnux-cli</code> uses.</p>"},{"location":"migrate/#design","title":"Design","text":"<p>A Cast distro is a bunch of SaltStack states and there's and how they are organized is very flexible but there is a recommended base organization. To support embedding states from one project into another project using git submodules, it is recommended that all base states start in the root of the project. A base state is generally a target for building like <code>desktop</code> or <code>server</code> or <code>dedicated</code> or <code>standalone</code>. All other states are encourage to be in subdirectories that make sense from a human readability and organization standpoint.</p> <p>This design allows for a distro to be submoduled into another distro.</p>"},{"location":"migrate/#development","title":"Development","text":"<p>During development of a Cast distro, Cast provides testing tools but if you'd like to use SaltStack directly you simply need to honor a few guidelines for how to setup your development environment. For example if you are building a distro called <code>example</code> you'd want your file root for saltstack to be <code>/tmp/salt</code> with your Cast distro cloned into <code>/tmp/salt/example</code>.</p>"},{"location":"migrate/#migrating","title":"Migrating","text":"<p>To migrate to Cast and to use Cast to manage all your releases there are a few steps that must be taken.</p> <ol> <li>Create a Cosign Private and Public Key</li> <li>Ensure you have your PGP Private and Public Key</li> <li>Create a <code>.cast.yml</code> file and populate it properly.</li> <li>Modify .gitignore</li> <li>Commit changes</li> <li>Create a tag</li> <li>Create a release</li> </ol>"},{"location":"migrate/#migration-by-example","title":"Migration by Example","text":"<p>The current version of SIFT is not in the recommended format. All base states exist in a subfolder within the root of the project, but Cast is designed to handle this scenario if it's required.</p> <p>To migrate SIFT as it is currently, the Cast file would look like the following.</p> <pre><code>version: 2\nname: sift\nbase_dir: sift\nmodes:\n  - name: server\n    state: sift.server\n    default: true\nsupported_os:\n  - id: ubuntu\n    release: 20.04\n    codename: focal\n</code></pre> <p>Since all the states exist within the <code>sift</code> folder we define the <code>base_dir</code> as sift, this is how we ensure files get packed and unpacked properly for execution. The modes are a carry over from the sift-cli and the easy modes that make represent an installation mode for the distro, modes allows for a default to be specified and what the modes are and what state should be called as a result, this allows for a great deal of flexibility by a distro author.</p> <p>Finally the supported OS provides a way to indicate if the target OS is supported or not.</p> <p>Once the <code>.cast.yml</code> is in place and committed to the repository, we can create our first tag and publish using Cast. Since we want to maintain backwards compatibility with the <code>sift-cli</code> we'll enable legacy signing using PGP.</p> <p>First, update your <code>.gitignore</code> and ignore <code>*.key</code></p> <p>Second, create your cosign keys.</p> <pre><code>cosign generate-key-pair\n</code></pre> <p>Note: whether you set a password or not, you'll need to set the environment variable <code>COSIGN_PASSWORD</code> with the value so that cast can use the key.</p> <p>Third, copy your PGP keys as <code>pgp.key</code> and <code>pgp.pub</code>.</p> <p>Note: if your PGP key is encryped you'll need to set <code>PGP_PASSWORD</code> as an environment viarable so that cast can use the key to sign.</p> <p>Fourth, create a new tag and push it to the remote.</p> <p>Finally, run Cast to release.</p> <pre><code>cast release --legacy-pgp-sign\n</code></pre> <p>This will do some basic validation and package the distro for release and upload all the assets to GitHub Releases.</p> <p>Congrats!</p>"}]}